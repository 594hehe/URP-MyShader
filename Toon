Shader "Toon/URP_Toon"
{
    Properties
    {
        [Header(Shader Setting)]
        [Space(5)]
        [KeywordEnum(Base,Hair,Face)] _ShaderEnum("Shader类型",int) = 0
        [Toggle] _IsNight ("In Night", int) = 0
        [Space(5)]

        [Header(Main Texture Setting)]
        [Space(5)]
		_WorldLightInfluence ("世界灯光", range(0.0, 1.0)) = 0.1
		[HDR][MainColor] _MainColor ("Main Color", Color) = (1.0, 1.0, 1.0, 1.0)
        [MainTexture] _MainTex ("Texture", 2D) = "white" {}
		[Normal]_NormalTex ("NormalTexture", 2D) = "black" {}
		_NormalScale ("NormalScale", Range(0, 1)) = 1
       
        [Space(30)]

        [Header(Shadow Setting)]
        [Space(5)]
		_Eyeslight("眼睛亮度", Range(0, 2)) = 1
        _LightMap ("LightMap", 2D) = "grey" {}
        _RampMap ("RampMap", 2D) = "white" {}
        _ShadowSmooth ("Shadow Smooth", Range(0, 1)) = 0.5
        _RampShadowRange ("Ramp Shadow Range", Range(0.5, 1.0)) = 0.8
        _RangeAO ("AO Range", Range(0, 2)) = 1.5
       // _ShadowColor ("Shadow Color", Color) = (1.0, 1.0, 1.0, 1.0)
		//_ShadowColor2 ("Shadow Color2", Color) = (1.0, 1.0, 1.0, 1.0)
		//_ShadowColor3 ("Shadow Color3", Color) = (1.0, 1.0, 1.0, 1.0)
		//_ShadowColor4 ("Shadow Color4", Color) = (1.0, 1.0, 1.0, 1.0)
		//_ShadowColor5 ("Shadow Color5", Color) = (1.0, 1.0, 1.0, 1.0)
		
		
		
		[IntRange]_RampArea1 ("Ramp1 Color", Range(0, 4)) = 0
        [IntRange]_RampArea2 ("Ramp2 Color", Range(0, 4)) = 1
        [IntRange]_RampArea3 ("Ramp3 Color", Range(0, 4)) = 2
		[IntRange]_RampArea4 ("Ramp4 Color", Range(0, 4)) = 3
		[IntRange]_RampArea5 ("Ramp5 Color", Range(0, 4)) = 4
        [Space(30)]

        [Header(Face Setting)]
        [Space(5)]
        _FaceShadowOffset ("Face Shadow Offset", range(0.0, 1.0)) = 0.1
        _FaceShadowPow ("Face Shadow Pow", range(0.001, 1)) = 0.1
        [Space(30)]

        [Header(Specular Setting)]
        [Space(5)]
        [Toggle] _EnableSpecular ("Enable Specular", int) = 1
        _MetalMap ("Metal Map", 2D) = "white" {}
        [HDR] _SpecularColor ("Specular Color", Color) = (1.0, 1.0, 1.0, 1.0)
        _BlinnPhongSpecularGloss ("Blinn Phong Specular Gloss", Range(0.01, 10)) = 5
        _BlinnPhongSpecularIntensity ("Blinn Phong Specular Intensity", Range(0, 1)) = 1
        _StepSpecularGloss ("Step Specular Gloss", Range(0, 1)) = 0.5
        _StepSpecularIntensity ("Step Specular Intensity", Range(0, 2)) = 0.5
        _MetalSpecularGloss ("Metal Specular Gloss", Range(0, 1)) = 0.5
        _MetalSpecularIntensity ("Metal Specular Intensity", Range(0, 5)) = 1
		
		
        [Space(30)]

        [Header(Rim Setting)]
        [Space(5)]
        [Toggle] _EnableRim ("Enable Rim", int) = 1
        [HDR] _RimColor ("Rim Color", Color) = (1.0, 1.0, 1.0, 1.0)
        _RimOffset ("边缘宽度", Range(0, 0.5)) = 0.1    //粗细
        _RimThreshold ("边缘阈值", Range(0, 2)) = 1  //细致程度
		_RimBrightness("边缘亮度",range(0,0.5)) = 0.1
        [Space(30)]

        [Header(Outline Setting)]
        [Space(5)]
        _OutlineWidth ("Outline Width", Range(0, 2)) = 0.5
        _OutlineColor ("Outline Color", Color) = (0, 0, 0, 1)
		
		 [Toggle(ENABLE_ALPHA_CLIPPING)]_EnableAlphaClipping ("EnableAlphaClipping", Float) = 0
        _Cutoff("Cutoff", Range(0,1)) = 0.5
    }
    SubShader
    {
        Tags { "RenderPipeline"="UniversalPipeline" "RenderType"="Opaque"}

        HLSLINCLUDE
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
        #pragma shader_feature _SHADERENUM_BASE _SHADERENUM_HAIR _SHADERENUM_FACE
		#pragma shader_feature_local_fragment ENABLE_ALPHA_CLIPPING
		
            #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS
            #pragma multi_compile_fragment _ _SHADOWS_SOFT
            #pragma multi_compile_fog

        int _IsNight;
        TEXTURE2D(_MainTex);            SAMPLER(sampler_MainTex);
		TEXTURE2D(_NormalTex);            SAMPLER(sampler_NormalTex);
        TEXTURE2D(_LightMap);           SAMPLER(sampler_LightMap);
        TEXTURE2D(_RampMap);            SAMPLER(sampler_RampMap);
        TEXTURE2D(_MetalMap);           SAMPLER(sampler_MetalMap);
        TEXTURE2D(_CameraDepthTexture); SAMPLER(sampler_CameraDepthTexture);

        // 单个材质独有的参数尽量放在 CBUFFER 中，以提高性能
        CBUFFER_START(UnityPerMaterial)
        float4 _MainTex_ST;
        half4 _MainColor;

        float4 _LightMap_ST;
        float4 _RampMap_ST;
        half _ShadowSmooth;
        half _RampShadowRange;
        //half4 _ShadowColor;
		//half4 _ShadowColor2;
		//half4 _ShadowColor3;
		//half4 _ShadowColor4;
		//half4 _ShadowColor5;
		float _WorldLightInfluence;
		float _WorldLight;
		float _RampArea1;
        float _RampArea2;
		float _RampArea3;
		float _RampArea4;
        float _RampArea5;
		float _RangeAO;
		float _NormalScale;
		float _RimBrightness;
		float _Eyeslight;
       
        int _EnableSpecular;
        float4 _MetalMap_ST;
        half4 _SpecularColor;
        half _BlinnPhongSpecularGloss;
        half _BlinnPhongSpecularIntensity;
        half _StepSpecularGloss;
        half _StepSpecularIntensity;
        half _MetalSpecularGloss;
        half _MetalSpecularIntensity;
		

        float _FaceShadowOffset;
        float _FaceShadowPow;

        int _EnableRim;
        half4 _RimColor;
        half _RimOffset;
        half _RimThreshold;

       
        half _OutlineWidth;
        half4 _OutlineColor;
		half _Cutoff;
		
        CBUFFER_END

        struct a2v{
            float3 vertex : POSITION;       //顶点坐标
            half4 color : COLOR0;           //顶点色
            half3 normal : NORMAL;          //法线
            half4 tangent : TANGENT;        //切线
            float2 texCoord : TEXCOORD0;    //纹理坐标
        };
        struct v2f{
            float4 pos : POSITION;              //裁剪空间顶点坐标
			//float4 positionCS : SV_POSITION;
            float2 uv : TEXCOORD0;              //uv
            float3 worldPos : TEXCOORD1;        //世界坐标
            float3 worldNormal : TEXCOORD2;     //世界空间法线
            float3 worldTangent : TEXCOORD3;    //世界空间切线
            float3 worldBiTangent : TEXCOORD4;  //世界空间副切线
            half4 color : COLOR0;               //平滑Rim所需顶点色
        };
		
		
        ENDHLSL

        Pass
        {
            Tags {"LightMode"="UniversalForward" "RenderType"="Opaque"}
			
			Cull off
            ZTest LEqual
            ZWrite On
            Blend One Zero
            
            HLSLPROGRAM
			#pragma target 3.0
            #pragma vertex ToonPassVert
            #pragma fragment ToonPassFrag
			#pragma shader_feature_local_fragment ENABLE_ALPHA_CLIPPING
			#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
			
			

            v2f ToonPassVert(a2v v)
            {
                v2f o;
                o.pos = TransformObjectToHClip(v.vertex);
                o.uv = TRANSFORM_TEX(v.texCoord, _MainTex);
                o.worldPos = TransformObjectToWorld(v.vertex);
                // 使用URP自带函数计算世界空间法线
                VertexNormalInputs vertexNormalInput = GetVertexNormalInputs(v.normal, v.tangent);
                o.worldNormal = vertexNormalInput.normalWS;
                o.worldTangent = vertexNormalInput.tangentWS;
                o.worldBiTangent = vertexNormalInput.bitangentWS;
                o.color = v.color;
                return o;
            }

            half4 ToonPassFrag(v2f i) : SV_TARGET
            {
                float4 BaseColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv) * _MainColor;
				
				#if ENABLE_ALPHA_CLIPPING
                    clip(BaseColor.a-_Cutoff);
                #endif
				
				
				half4 NormalTex = SAMPLE_TEXTURE2D(_NormalTex,sampler_NormalTex,i.uv); //法线贴图
				
				
				
				
				float3 normalTS = UnpackNormalScale(NormalTex,_NormalScale);               //控制法线强度
				normalTS.z = pow((1 - pow(normalTS.x,2) - pow(normalTS.y,2)),0.5);         //规范化法线 
				float3 norWS = mul(normalTS,i.worldNormal);  
				
                float4 LightMapColor = SAMPLE_TEXTURE2D(_LightMap, sampler_LightMap, i.uv);
                Light mainLight = GetMainLight();
                half4 LightColor = half4(mainLight.color, 1.0);
                half3 lightDir = normalize(mainLight.direction);
                half3 viewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
                half3 halfDir = normalize(viewDir + lightDir);

                half halfLambert = dot(lightDir, i.worldNormal) * 0.5 + 0.5;

                //==========================================================================================
                // Base Ramp
                // 依据原来的lambert值，保留0到一定数值的smooth渐变，大于这一数值的全部采样ramp最右边的颜色，从而形成硬边
                halfLambert = smoothstep(0.0, _ShadowSmooth, halfLambert);
                // 常暗阴影
                float ShadowAO = smoothstep(0, 0.3, LightMapColor.g);

                float RampPixelX = 0.00390625;  //0.00390625 = 1/256
                float RampPixelY = 0.03125;     //0.03125 = 1/16/2   尽量采样到ramp条带的正中间，以避免精度误差
                float RampX, RampY;
				float rampVmove = 0.0;
                // 对X做一步Clamp，防止采样到边界
                RampX = clamp(halfLambert*ShadowAO, RampPixelX, 1-RampPixelX);
 // Base Ramp
				
                if (_IsNight == 0.0)
                    rampVmove=0;
                else
                    rampVmove=-0.5;
                // 灰度0.0-0.2  硬Ramp
                // 灰度0.2-0.4  软Ramp
                // 灰度0.4-0.6  金属层
                // 灰度0.6-0.8  布料层，主要为silk类
                // 灰度0.8-1.0  皮肤/头发层
                // 白天采样上半，晚上采样下半
                    float4 ShadowRamp1 = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, float2(RampX, 0.95+rampVmove));
                    float4 ShadowRamp2 = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, float2(RampX, 0.85+rampVmove));
                    float4 ShadowRamp3 = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, float2(RampX, 0.75+rampVmove));
                    float4 ShadowRamp4 = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, float2(RampX, 0.65+rampVmove));
                    float4 ShadowRamp5 = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, float2(RampX, 0.55+rampVmove));
                   
					float4 AllRamps[5] = {
                        ShadowRamp1, ShadowRamp2, ShadowRamp3, ShadowRamp4, ShadowRamp5
                    };
					float4 eyes=smoothstep(0.51, 1, LightMapColor.g);
					float4 eyes1=smoothstep(1, 0.51, LightMapColor.g);//眼睛分离
					float4 skinRamp = step(abs(LightMapColor.a * 255 - 255), 39) * AllRamps[_RampArea1]-eyes; // CoolShadowRamp2
                    float4 tightsRamp = step(abs(LightMapColor.a * 255 - 128), 39) * AllRamps[_RampArea2]-eyes; // CoolShadowRamp5
                    float4 softCommonRamp = step(abs(LightMapColor.a * 255 - 0), 39) * AllRamps[_RampArea3]-eyes; // CoolShadowRamp1
                    float4 hardSilkRamp = step(abs(LightMapColor.a * 255 - 77), 39) * AllRamps[_RampArea4]-eyes; // CoolShadowRamp3
                    float4 metalRamp = step(abs(LightMapColor.a * 255 - 178), 39) * AllRamps[_RampArea5]-eyes; // CoolShadowRamp4
                //— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
               

                
                float4 rampColor =skinRamp + tightsRamp + metalRamp + softCommonRamp + hardSilkRamp;
                float4 FinalRamp = lerp(rampColor * BaseColor , BaseColor, step(_RampShadowRange, halfLambert * ShadowAO));
				FinalRamp=eyes1*FinalRamp+(eyes*BaseColor*_Eyeslight);




                //— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
                // Hair Ramp
              //  #if _SHADERENUM_HAIR
             //       if (_IsNight == 0.0)
            //            RampY = RampPixelY * (33 - 2 * lerp(1, 3, step(0.5, LightMapColor.a)));
          //          else
             //           RampY = RampPixelY * (17 - 2 * lerp(1, 3, step(0.5, LightMapColor.a)));
            //        RampUV = float2(RampX, RampY);
           //         rampColor = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, RampUV);
           //         FinalRamp = lerp(rampColor * BaseColor * _ShadowColor, BaseColor, step(_RampShadowRange, halfLambert * ShadowAO));
          //      #endif

                //— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
                // SDF脸部阴影
                #if _SHADERENUM_FACE
                    float4 upDir = mul(unity_ObjectToWorld, float4(0,1,0,0));  
                    float4 frontDir = mul(unity_ObjectToWorld, float4(0,0,1,0));
                    float3 rightDir = cross(upDir, frontDir);

                    float FdotL = dot(normalize(frontDir.xz), normalize(lightDir.xz));
                    float RdotL = dot(normalize(rightDir.xz), normalize(lightDir.xz));
                    // 切换贴图正反
                    float2 FaceMapUV = float2(lerp(i.uv.x, 1-i.uv.x, step(0, RdotL)), i.uv.y);
                    float FaceMap = SAMPLE_TEXTURE2D(_LightMap, sampler_LightMap, FaceMapUV).r;
                    // 下面这句话是错的
                    //float FaceMap = lerp(LightMapColor.r, 1-LightMapColor.r, step(0, RdotL)) * step(0, FdotL);

                    // 调整变化曲线，使得中间大部分变化速度趋于平缓
                    FaceMap = pow(FaceMap, _FaceShadowPow);

                    // 直接用采样的结果和FdotL比较判断，头发阴影和面部阴影会对不上，需要手动调整偏移
                    // 但是直接在LightMap数据上±Offset会导致光照进入边缘时产生阴影跳变
                    float sinx = sin(_FaceShadowOffset);
                    float cosx = cos(_FaceShadowOffset);
                    float2x2 rotationOffset1 = float2x2(cosx, sinx, -sinx, cosx); //顺时针偏移
                    float2x2 rotationOffset2 = float2x2(cosx, -sinx, sinx, cosx); //逆时针偏移
                    float2 FaceLightDir = lerp(mul(rotationOffset1, lightDir.xz), mul(rotationOffset2, lightDir.xz), step(0, RdotL));
                    FdotL = dot(normalize(frontDir.xz), normalize(FaceLightDir));

                    //FinalRamp = float4(FaceMap, FaceMap, FaceMap, 1);
                    FinalRamp = lerp(BaseColor, _ShadowColor * BaseColor, step(FaceMap, 1-FdotL));
                #endif

                //==========================================================================================
                // 高光
                half4 BlinnPhongSpecular;
               half4 MetalSpecular;
               half4 StepSpecular;
               half4 FinalSpecular;
                // ILM的R通道，灰色为裁边视角高光
               half StepMask = step(0.2, LightMapColor.r) - step(0.8, LightMapColor.r);
               StepSpecular = step(1 - _StepSpecularGloss, saturate(dot(i.worldNormal, viewDir))) * _StepSpecularIntensity * StepMask;
                // ILM的R通道，白色为 Blinn-Phong + 金属高光
               half MetalMask = step(0.9, LightMapColor.r);
                 //Blinn-Phong
                BlinnPhongSpecular = pow(max(0, dot(i.worldNormal, halfDir)), _BlinnPhongSpecularGloss) * _BlinnPhongSpecularIntensity * MetalMask;
                // 金属高光
                float2 MetalMapUV = mul((float3x3) UNITY_MATRIX_V, i.worldNormal).xy * 0.5 + 0.5;
                float MetalMap = SAMPLE_TEXTURE2D(_MetalMap, sampler_MetalMap, MetalMapUV).r;
                MetalMap = saturate(step(_MetalSpecularGloss, MetalMap));
                MetalSpecular = MetalMap * _MetalSpecularIntensity * MetalMask;
                
                FinalSpecular = StepSpecular + BlinnPhongSpecular + MetalSpecular;
                FinalSpecular = lerp(0, BaseColor * FinalSpecular * _SpecularColor, LightMapColor.b) ;
                FinalSpecular *= halfLambert * ShadowAO * _EnableSpecular;







                //==========================================================================================
                // 屏幕空间深度等宽边缘光
                // 屏幕空间UV
                float2 RimScreenUV = float2(i.pos.x / _ScreenParams.x, i.pos.y / _ScreenParams.y);
                // 法线外扩偏移UV，把worldNormal转换到NDC空间
                float3 smoothNormal = normalize(UnpackNormalmapRGorAG(i.color));
                float3x3 tangentTransform = float3x3(i.worldTangent, i.worldBiTangent, i.worldNormal);
                float3 worldRimNormal = normalize(mul(smoothNormal, tangentTransform));
                float2 RimOffsetUV = float2(mul((float3x3) UNITY_MATRIX_V, worldRimNormal).xy * _RimOffset * 0.01 / i.pos.w);
                RimOffsetUV += RimScreenUV;
                
                float ScreenDepth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, RimScreenUV);
                float Linear01ScreenDepth = LinearEyeDepth(ScreenDepth, _ZBufferParams);
                float OffsetDepth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, RimOffsetUV);
                float Linear01OffsetDepth = LinearEyeDepth(OffsetDepth, _ZBufferParams);

                float diff = Linear01OffsetDepth - Linear01ScreenDepth;
                float rimMask = step(_RimThreshold * 0.1, diff);
                // 边缘光颜色的a通道用来控制边缘光强弱
                float4 RimColor = float4(rimMask * _RimColor.rgb * _RimColor.a, 1) * _EnableRim*_RimBrightness;
                float4 FinalColor = FinalRamp + FinalSpecular + RimColor;
				
				FinalColor = (_WorldLightInfluence * LightColor * FinalColor + (1 - _WorldLightInfluence) * FinalColor);
                //return LightMapColor.r;
                return FinalColor;
				//return FinalSpecular;
            }
            ENDHLSL
        }

        Pass {
            Name "OutLine"
            Tags{ "LightMode" = "SRPDefaultUnlit" }
	         Cull front
	         HLSLPROGRAM
	        #pragma vertex vert  
	         #pragma fragment frag
			 #pragma fragment FragmentAlphaClip
			 #pragma shader_feature_local_fragment ENABLE_ALPHA_CLIPPING
	          v2f vert(a2v input) {
                float4 scaledScreenParams = GetScaledScreenParams();
                float ScaleX = abs(scaledScreenParams.x / scaledScreenParams.y);//求得X因屏幕比例缩放的倍数
		      v2f output;
		          VertexPositionInputs vertexInput = GetVertexPositionInputs(input.vertex.xyz);
                VertexNormalInputs normalInput = GetVertexNormalInputs(input.normal);
                float3 normalCS = TransformWorldToHClipDir(normalInput.normalWS);//法线转换到裁剪空间
                float2 extendDis = normalize(normalCS.xy) *(_OutlineWidth*0.01);//根据法线和线宽计算偏移量
                extendDis.x /=ScaleX ;//由于屏幕比例可能不是1:1，所以偏移量会被拉伸显示，根据屏幕比例把x进行修正
                output.pos = TransformObjectToHClip(input.vertex);
				float ctrl = clamp(5/output.pos.w,0,1);//最远描边宽度
                #if _OLWVWD_ON
                    //屏幕下描边宽度会变
                    output.pos.xy +=extendDis;
                #else
                    //屏幕下描边宽度不变，则需要顶点偏移的距离在NDC坐标下为固定值
                    //因为后续会转换成NDC坐标，会除w进行缩放，所以先乘一个w，那么该偏移的距离就不会在NDC下有变换
                    //output.pos.xy += extendDis * output.pos.w* ctrl;
					output.pos.xy += extendDis * output.pos.w* ctrl*input.color.a;//顶点色控制粗细
                #endif
				
                
		      return output;
	     }
	     float4 frag(v2f input) : SV_Target {
                 return float4(_OutlineColor.rgb, 1);
	     }
            ENDHLSL
        }
		Pass
        {
            Tags {"LightMode" = "ShadowCaster"}
        }

        Pass
        {
            Tags {"LightMode" = "DepthOnly"}
        }
    }
}
